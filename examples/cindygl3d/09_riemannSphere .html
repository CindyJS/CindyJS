<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Cindy JS</title>
        <script type="text/javascript" src="../../build/js/Cindy.js"></script>
        <script type="text/javascript" src="../../build/js/CindyGL3D.js"></script>
        <link rel="stylesheet" href="../../css/cindy.css" />
    </head>

    <body style="font-family: Arial">
        <h1>CindyGL3D: Riemann Sphere</h1>

        <script id="csmousedown" type="text/x-cindyscript">
            x0 = mouse().x;
            y0 = mouse().y;
            dragging = x0 < 2;
        </script>
        <script id="csmouseup" type="text/x-cindyscript">
            dragging = false;
        </script>
        <script id="csinit" type="text/x-cindyscript">
            use("CindyGL3D");
            sx = mouse().x;
            sy = mouse().y;
            dragging = false;
            oo=1000;

            color(z) := ( //what color should be given to a complex number z?
              regional(n, grey1, grey2);
              n = 12;
              z = log(z)/2/pi;

              zfract = n*z - floor(n*z); //value of n*z in C mod Z[i]

              grey1 = im(zfract);
              grey2 = re(zfract);

              hue(im(z))*(.9+.1*re(sqrt(grey1*grey2)));
            );
            normalize(v):=(v/|v|);            
            cglSphereNormalAndDepth(direction):=(
              // |v+l*d -c|=r
              vc=cglViewPos-cglCenter;
              // -> l*l <d,d> + l * 2<v-c,d> + <v-c,v-c> - r*r
              b2=(vc*direction); // 1/2 * b
              c=vc*vc-cglRadius*cglRadius;
              D4=b2*b2-c; // 1/4* ( b*b - 4 *a*c)
              if(D4<0,
                [0,0,0,oo],
                dst=-b2-re(sqrt(D4));// sqrt should always be real
                pos3d = cglViewPos+ dst*direction;
                normal = normalize(pos3d - cglCenter);
                [normal_1,normal_2,normal_3,dst]
              )
            );

            cglBegin3d();
            update():=(
              cglReset3d();
              f(direction):=(
                normalAndDepth=cglSphereNormalAndDepth(direction);
                depth=normalAndDepth_4;
                z=((normalAndDepth_1)/(1-normalAndDepth_3))
                  +i*((normalAndDepth_2)/(1-normalAndDepth_3));
                fz=expr(z);
                brigthness = 0.25+0.75*max(0,-normal*direction);// TODO better ligth calucation
                colRGB = brigthness*color(fz);
                cglDepth = depth/16;
                [colRGB_1,colRGB_2,colRGB_3,if(depth>=oo,0,1)]
              );
              colorplot3d(f(#),[0,0,0],1);
            );
            // expression is set during script initialisation
            update();
        </script>
        <script id="csdraw" type="text/x-cindyscript">
            if (dragging,
                dx = (mouse().x -sx); dy = (mouse().y -sy);
                rotate3d(dx,dy);
            );

            sx = mouse().x;
            sy = mouse().y;

            cglDraw3d();
        </script>

        <div id="CSCanvas" style="border: 0px"></div>

        <div>
          <input
              type="text"
              id="exprInput"
              value="(z^2+1/4)/(z^3-1/27)"
              onkeypress="if((event.which ? event.which : event.keyCode)==13) { inputChanged() }"
              size="60"
              style="font-size: 18px"
          />
        </div>
        <script type="text/javascript">
            function inputChanged(){
              cdy.evokeCS('expr(z) := (' + exprInput.value + ');');
            }
            let cdy = CindyJS({
                canvasname: "CSCanvas",
                scripts: "cs*",
                animation: { autoplay: true },
                ports: [
                    {
                        id: "CSCanvas",
                        width: 512,
                        height: 512,
                        transform: [{ visibleRect: [-1.2, -1.2, 1.2, 1.2] }],
                    },
                ]
            });
            inputChanged();
        </script>
    </body>
</html>

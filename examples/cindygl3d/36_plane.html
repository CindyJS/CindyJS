<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Cindy JS</title>
        <script type="text/javascript" src="../../build/js/Cindy.js"></script>
        <script type="text/javascript" src="../../build/js/CindyGL.js"></script>
        <link rel="stylesheet" href="../../css/cindy.css" />
    </head>

    <body style="font-family: Arial">
        <script id="csmousedown" type="text/x-cindyscript">
            sx = mouse().x;
            sy = mouse().y;
            if(target < 0,
              rotating = true;
            ,
              dragging = true;
            );
        </script>
        <script id="csmouseup" type="text/x-cindyscript">
            dragging = false;
            rotating = false;
        </script>
        <script id="csinit" type="text/x-cindyscript">
            use("CindyGL");

            sx = mouse().x;
            sy = mouse().y;
            dragging = false;
            rotating = false;
            phi=(1+sqrt(5))/2;

            cglBegin3d();
            s=2.5;
            r0=.15; // radius spheres
            r1=.05; // radius axes
            r2= 0.7; // length axes
            CUTsPHERE = 0;
            CUTcYLINDER = 1;
            CUTcUBE = 2;
            cutoff = CUTcYLINDER; // TODO? allow chainging base parameters of cutoff (center, ptA,ptB,radius)
            // TODO? use 3 points to controll bounds
            // sphere: center, _ , point on sphere
            // cylinder: center, pointA, point on cylinder
            // cuboid: center, midpoint top.face, point on face2

            col=[1,0,0];
            colSelected=[0,1,0];
            coordColXY = [0,1,0,0.5];
            coordColZ = [1,0,0,0.5];
            coordColInactive = [0,0,0,0];
            surfaceColor = [0,0.5,0.5,0.5];

            pointIds = [
              sphere([1,1,1],r0,col,tags->["movable"])_1,
              sphere([1,1,-1],r0,col,tags->["movable"])_1,
              sphere([1,-1,1],r0,col,tags->["movable"])_1
            ];
            xAxisIds = cylinder([-s,0,0],[s,0,0],r1,coordColInactive,coordColInactive);
            yAxisIds = cylinder([0,-s,0],[0,s,0],r1,coordColInactive,coordColInactive);
            zAxisIds = cylinder([0,0,-s],[0,0,s],r1,coordColInactive,coordColInactive);
            surfaceIds = [];
            // draw quadric curve through 9 points
            updateSurface():=(
              regional(pts,pos3,V);
              // homogeneous coordinates
              pts = apply(pointIds,pId,pos3=cglSpherePos(pId);[pos3_1,pos3_2,pos3_3,1]);
              // pad to square matrix
              V = transpose(kernel(pts++[[0,0,0,0]]))_1; // ignore additionl solutions in degenerate case
              if(length(surfaceIds) == 0,
                if(cutoff == CUTsPHERE,
                  surfaceIds = [cglDrawPlaneInSphere(V,[0,0,0],s,surfaceColor)]; // (matrix, boundCenter, boundRadius, color)
                  // surfaceIds = surfaceIds ++ sphere([0,0,0],s,[1,0,0,0.5]);
                ,if(cutoff == CUTcYLINDER,
                  surfaceIds = [cglDrawPlaneInCylinder(V,[0,-s,0],[0,s,0],s,surfaceColor)]; // (matrix, boundPtA, boundsPtB, boundRadius, color
                  surfaceIds = surfaceIds ++ cylinder([0,-s,0],[0,s,0],s,[1,0,0,0.5],[1,0,0,0.5]);
                ,
                  surfaceIds = [cglDrawPlaneInCube(V,[0,0,0],s,surfaceColor)]; // (matrix, boundCenter, boundSideLen, color
                ));
              ,
                apply(surfaceIds,id,cglUpdate(id,UcglCoeffVector->V));
              );
            );
            updateSurface();
            prevTarget=-1;
            target = -1;
            zoom=1.0;
            updateZoom():=(
              if(zoom>5,zoom=5);
              if(zoom<0.5,zoom=0.5);
              zoom3d(zoom);
              // rescale cutoff region
              if(cutoff == CUTsPHERE,
                apply(surfaceIds,id,cglUpdateBounds(id,[0,0,0],zoom*s));
              ,if(cutoff == CUTcYLINDER,
                apply(surfaceIds,id,cglUpdateBounds(id,zoom*[0,-s,0],zoom*[0,s,0],zoom*s));
              ,
                apply(surfaceIds,id,cglUpdateBounds(id,[0,0,0],sqrt(3)*zoom*s));              
              ));
            );
        </script>
        <script id="csdraw" type="text/x-cindyscript">
            if(rotating,
              dx = 4 * (mouse().x -sx); dy = 4 * (mouse().y -sy);
              rotate3d(dx,dy)
            );
            if (dragging,
              viewPos = cglViewPos();
              // view direction for given screen pixel
              oldDirection = cglDirection(sx,sy);
              newDirection = cglDirection(mouse().x,mouse().y);
              // movePlaneNormal * (viewPos+ t*direction) = movePlaneOffset
              // t * movePlaneNormal * direction =  movePlaneOffset - movePlaneNormal* viewPos;
              oldT = (movePlaneOffset - movePlaneNormal * viewPos) / (movePlaneNormal * oldDirection);
              newT = (movePlaneOffset - movePlaneNormal * viewPos) / (movePlaneNormal * newDirection);
              oldPos = viewPos + oldT*oldDirection;
              newPos = viewPos + newT*newDirection;
              truePos = cglSpherePos(target);
              newPos = newPos+(truePos-oldPos);
              cglUpdateBounds(target,newPos,r0);
              updateSurface();
            );
            sx = mouse().x;
            sy = mouse().y;

            tagList=[];
            if(!dragging,
              target = cglFindObject(sx,sy,tags->["movable"]);
              if(target!=prevTarget,
                if(prevTarget >= 0,
                  cglUpdate(prevTarget,UcglDrawColor->col);
                  apply(xAxisIds,id,cglUpdate(id,UcglDrawColorA->coordColInactive,UcglDrawColorB->coordColInactive));
                  apply(yAxisIds,id,cglUpdate(id,UcglDrawColorA->coordColInactive,UcglDrawColorB->coordColInactive));
                  apply(zAxisIds,id,cglUpdate(id,UcglDrawColorA->coordColInactive,UcglDrawColorB->coordColInactive));
                );
                if(target >= 0,
                  cglUpdate(target,UcglDrawColor->colSelected);
                  axes=cglAxes();
                  viewPos = cglViewPos();
                  coordCols=[coordColXY,coordColXY,coordColXY];
                  maxDot = abs(axes_1_3);
                  maxIndex = 1;
                  if(abs(axes_2_3) > maxDot,
                    maxDot = abs(axes_2_3);
                    maxIndex = 2;
                  );
                  if(abs(axes_3_3) > maxDot,
                    maxDot = abs(axes_3_3);
                    maxIndex = 3;
                  );
                  coordCols_maxIndex = coordColZ;
                  targetPos = cglSpherePos(target);
                  movePlaneNormal = [[1,0,0],[0,1,0],[0,0,1]]_maxIndex;
                  movePlaneOffset = movePlaneNormal*targetPos;
                  apply(xAxisIds,id,cglUpdate(id,UcglDrawColorA->coordCols_1,UcglDrawColorB->coordCols_1));
                  apply(yAxisIds,id,cglUpdate(id,UcglDrawColorA->coordCols_2,UcglDrawColorB->coordCols_2));
                  apply(zAxisIds,id,cglUpdate(id,UcglDrawColorA->coordCols_3,UcglDrawColorB->coordCols_3));
                );
                prevTarget=target;
              );
            );
            if(target != -1,
              targetPos = cglSpherePos(target);
              apply(xAxisIds,id,cglUpdateBounds(id,[targetPos_1-r2,targetPos_2,targetPos_3],
                [targetPos_1+r2,targetPos_2,targetPos_3],r1));
              apply(yAxisIds,id,cglUpdateBounds(id,[targetPos_1,targetPos_2-r2,targetPos_3],
                [targetPos_1,targetPos_2+r2,targetPos_3],r1));
              apply(zAxisIds,id,cglUpdateBounds(id,[targetPos_1,targetPos_2,targetPos_3-r2],
                [targetPos_1,targetPos_2,targetPos_3+r2],r1));
            );

            cglRender3d();
        </script>

        <div id="CSCanvas" style="border: 0px"></div>

        <script type="text/javascript">
            // zoom using mouse wheel
            window.addEventListener("wheel", // use only sign as value range may differ depending on browser
              event => cdy.evokeCS(`zoom=zoom*${Math.pow(1.05,Math.sign(event.deltaY))};updateZoom();`)
            );
            let cdy = CindyJS({
                canvasname: "CSCanvas",
                scripts: "cs*",
                animation: { autoplay: true },
                ports: [
                    {
                        id: "CSCanvas",
                        width: 512,
                        height: 512,
                        transform: [{ visibleRect: [-3, -3, 3, 3] }],
                    },
                ],
                import: {
                    "init": ["../../plugins/cindygl/scripts/cglInit.cjs"]
                }
            });
        </script>
    </body>
</html>

/*jshint -W030 */
'use strict'; // So this file can be used as a stand-alone node module
/*jshint +W030 */

// All operators, sorted by precedence level
var operatorLevels = [{
    key: [':'],
    field: ['.'],
    deg: ['°'],
    take: ['_'],
}, {
    rassoc: true,
    pow: ['^'],
    sqrt: ['√'],
}, {
    mul: ['*', '\u2062', '⋅'], // U+2062 = invisible times
    cross: ['×'],
    div: ['/'],
}, {
    add: ['+'],
    sub: ['-', '−'],
    neg: ['!', '¬'],
}, {
    seq: ['..'],
}, {
    eq: ['==', '≟'],
    ne: ['!=', '<>', '≠'],
    lt: ['<'],
    gt: ['>'],
    le: ['<=', '≤', '≦'],
    ge: ['>=', '≥', '≧'],
    aeq: ['~=', '≈'],
    ane: ['~!=', '≉'],
    alt: ['~<', '⪉'],
    agt: ['~>', '⪊'],
    ale: ['~<=', '⪅'],
    age: ['~>=', '⪆'],
    'in': ['∈'],
    nin: ['∉'],
}, {
    and: ['&', '∧'],
    or: ['%', '∨'],
}, {
    concat: ['++', '∪'],
    remove: ['--', '∖'],
    common: ['~~', '∩'],
    append: [':>'],
    prepend: ['<:'],
}, {
    rassoc: true,
    assign: ['='],
    define: [':='],
    undefine: [':=_'],
    bdefine: ['::='],
    modif: ['->', '→'],
}, {
    seq: [';'],
}, {
    rassoc: true,
    list: [','],
}];

var prefixOperators = ['+', '-'];
var prefixOnly = ['!', '√'];
var postfixOnly = ['°'];
var flexfix = [';', ','];

var operatorSymbols = [];
var operators = {};

(function initializeOperators() {
    var precedence = 0;
    operatorLevels.forEach(function(level) {
        precedence += 2;
        var rassoc = !!level.rassoc;
        for (var name in level) {
            var symbols = level[name];
            if (typeof symbols === 'boolean')
                continue;
            var descr = {
                name: name,
                sym: symbols[0],
                symbols: symbols,
                rassoc: rassoc,
                precedence: precedence,
                prefix: false,
                postfix: false,
                infix: true,
                bare: false,
            };
            for (var i = 0; i < symbols.length; ++i) {
                var symbol = symbols[i];
                if (operators.hasOwnProperty(symbol))
                    throw Error('Duplicate operator: ' + symbol);
                operators[symbol] = descr;
                operatorSymbols.push(symbol);
            }
        }
    });
    prefixOperators.forEach(function(op) {
        operators[op].prefix = true;
    });
    prefixOnly.forEach(function(op) {
        operators[op].prefix = true;
        operators[op].infix = false;
    });
    postfixOnly.forEach(function(op) {
        operators[op].postfix = true;
        operators[op].infix = false;
    });
    flexfix.forEach(function(op) {
        operators[op].prefix = true;
        operators[op].postfix = true;
        operators[op].infix = true;
        operators[op].bare = true;
    });
})();

operatorSymbols.sort(function(a, b) {
    return b.length - a.length;
});

var brackets = '[](){}||';

var whitespace = '[ \t\n]';

// Allow spaces in tokens. Any occurrence of ' ' is replaced by '[…]*',
// with […] matching the class of allowed in-token whitespace.
function expandSpaces(str) {
    return str.replace(/ /g, whitespace + '*');
}

// Quote special characters in strings so they can be used in regular
// expressions without triggering any special meaning
function rescape(str) {
    return str.replace(/[^A-Za-z0-9 \u0080-\uffff]/ig, '\\$&');
}

// Quote string, but allow whitespace anywhere in its body
function withSpaces(str) {
    return expandSpaces(rescape(str.replace(/.(?=.)/g, '$& ')));
}

// Form a group consisting matching any of the given strings literally,
// but with whitespace allowed.
function anyOfGroup(lst) {
    return '(' + lst.map(withSpaces).join('|') + ')';
}

// Either an integer part, possibly followed by a possibly empty
// fractional part, possibly followed by an exponent, or a leading dot
// followed by a non-empty fractional part, possibly followed by an
// exponent.
var reNumber = expandSpaces(
    '(?:[0-9](?: [0-9])*(?: \\.(?! \\.)(?: [0-9])*)?|\\.(?: [0-9])+)' +
    '(?: [Ee](?: [+-])?(?: [0-9])+)?'
);

// Letters (Unicode 6.2.0 category L) in the basic multilingual plane
// (no surrogate pairs needed). Generated by tools/unicodeCat.js.
var bmpLetters = (function(d, s) {
    var i;
    var j = 0;
    var c = [];
    var n = s.length;
    for (i = 0; i < n; ++i)
        c[i] = j = d[s.charCodeAt(i) - 32] + j;
    var r = "";
    for (i = 0; i < n; i += 2) {
        r += String.fromCharCode(c[i]);
        if (c[i + 1] !== c[i])
            r += "-" + String.fromCharCode(c[i + 1]);
    }
    return r;
})([
    2, 0, 277, 3, 4, 6, 1, 5, 7, 10, 17, 22, 8, 9, 11, 15, 12, 13, 21, 25, 16,
    46, 18, 19, 30, 37, 40, 14, 24, 29, 36, 42, 52, 53, 26, 27, 28, 32, 35, 43,
    88, 20, 23, 33, 34, 38, 47, 48, 49, 51, 56, 59, 63, 65, 68, 69, 102, 117,
    31, 39, 268, 41, 45, 50, 54, 55, 57, 64, 66, 72, 73, 74, 75, 78, 81, 82, 83,
    84, 85, 87, 89, 93, 94, 98, 105, 107, 108, 116, 130, 132, 134, 138, 146,
    157, 191, 332, 362, 365, 457, 470, 513, 619, 1164, 2684, 6581, 8453, 11171,
    20940
], ("U3(3O!.!'!%+ 8 \x82'./$,! !x$ &##-!   ! 7 k {-})9#!,MfB% 5?>& s !4&,&. " +
    "#!*! =8H0!3E)&'!%2'!)!$!<<e! )HA$!7!,-4% %%(#&#2 % !$#$!*!;&  /&I''&#2 " +
    "% & & &E# !I *,   2 % & $$!7!4&>(#&#2 % & $$!Z&  4!6! '$  #$& ! &$&$ $." +
    "J!A(   + - $$!C&(&>(   + - $$!K! &4&7(   :#!*!6&3'%*$J , !#%SN &1%S& !#" +
    "& !#!(# %   ! !#& # &)!#$ !+#K!c( FD$w?2!*''#$!$&, '01!69 !%!#? \x7f ##" +
    "% ! ##: ##E ##% ! ##; R ##dM/*m1\x85#4 3%g+0 #/*/*/0  4Q>!'!Vo-: !%W.D@" +
    "=#$0G+%b+)@l!r56%R=;&.GCF? .Fv# #$&)~U\"#'#9#'#( ! ! ! 8#@ % !$  %$##''" +
    "0%  %Y!;!*0X!'!#- !$$(! ! ! # )##%$'!A&\x875 5 y(#$&19 !%!#a,!*+)% % % " +
    "% % % % %j!\x83&G$%&'n(  p #%:$q6B`/\x84\x88h\x8b@\x86V^#\\$/.&25*<-W_," +
    "#X## #1)i-   # +8Q/PT'$!/C.+BD,5=!P:<  (2+$!%N !$&#$#! !3 #), 1'#'#')% " +
    "%|L8\x8a1+'O\x89\x81#t[%1$%! - 0 $ ! & & uL\x807T#A].Y$ z93(30H$'#'#'# "));

var reIdentifier = expandSpaces(
    "(?:#(?: [1-9])?|['" + bmpLetters + "](?: [0-9'" + bmpLetters + "])*)"
);

var reNextToken = [ //               0: token text
    '(' + whitespace + '+)', //        1: whitespace
    '(//.*)', //                       2: comment
    '(' + reNumber + ')', //           3: number literal
    anyOfGroup(operatorSymbols), //    4: operator
    anyOfGroup(brackets.split('')), // 5: bracket
    '(' + reIdentifier + ')', //       6: identifier
    '("[^"]*")', //                    7: string literal
    '($)', //                          8: EOF
].join('|');

var reSpace = new RegExp(whitespace + '+', 'g');

var tokenTypes = [
    'ANY', 'WS', 'COMMENT', 'NUM', 'OP', 'BRA', 'ID', 'STR', 'EOF'
];

(function sanityCheck() {
    var re = new RegExp(reNextToken, 'g');
    var match = re.exec('');
    if (match.hasOwnProperty(tokenTypes.length))
        throw Error('RE has more groups than expected');
    if (!match.hasOwnProperty(tokenTypes.length - 1))
        throw Error('RE has fewer groups than expected');
})();

function ParseError(message, location, text) {
    var msg = message;
    if (location)
        msg = msg + ' at ' + location.row + ':' + location.col;
    if (text)
        msg = msg + ': ‘' + text + '’';
    var err = Error(msg);
    err.name = 'CindyScriptParseError';
    err.description = message;
    err.location = location;
    err.text = text;
    return err;
}

function Tokenizer(input) {
    this.input = input;
    this.re = new RegExp(reNextToken, 'g');
    var bols = []; // beginnings of lines
    var pos = input.indexOf('\n') + 1;
    while (pos) {
        bols.push(pos);
        pos = input.indexOf('\n', pos) + 1;
    }
    bols.push(input.length);
    this.bols = bols;
    this.pos = 0;
    this.bol = 0;
    this.line = 1;
}

Tokenizer.prototype.advance = function(offset) {
    this.pos += offset;
    while (this.bols[0] <= this.pos) {
        this.bol = this.bols.shift();
        this.line++;
    }
};

Tokenizer.prototype.curPos = function() {
    return {
        row: this.line,
        col: this.pos - this.bol,
        pos: this.pos
    };
};

Tokenizer.prototype.nextInternal = function() {
    var match = this.re.exec(this.input);
    if (match.index !== this.pos)
        throw ParseError('Invalid token', this.curPos(),
            this.input.substring(this.pos, match.index));
    var pos1 = this.curPos();
    this.advance(match[0].length);
    var pos2 = this.curPos();
    var tt;
    /*jshint -W116 */
    for (tt = 1; match[tt] == null; ++tt) {} // neither null nor undefined
    /*jshint +W116 */
    return {
        start: pos1,
        end: pos2,
        raw: match[0],
        text: match[0].replace(reSpace, ''),
        toktype: tokenTypes[tt]
    };
};

Tokenizer.prototype.next = function() {
    var tok;
    do {
        tok = this.nextInternal();
    } while (tok.toktype === 'WS' || tok.toktype === 'COMMENT');
    return tok;
};

// Take a sequence ending in […, ‹lhs›, ‹op›, ‹rhs›] and turn it into
// […, ‹op›], but record ‹lhs› and ‹rhs› as args of ‹op›.
function applyOperator(seq) {
    var op = seq[seq.length - 2];
    var lhs = seq[seq.length - 3];
    var rhs = seq[seq.length - 1];
    if (lhs) {
        if (rhs) { // expr op expr
            if (!op.op.infix)
                throw ParseError(
                    'Operator may not be used infix',
                    op.start, op.text);
        } else { // expr op null
            if (!op.op.postfix)
                throw ParseError(
                    'Operator may not be used postfix',
                    op.start, op.text);
        }
    } else {
        if (rhs) { // null op expr
            if (!op.op.prefix)
                throw ParseError(
                    'Operator may not be used prefix',
                    op.start, op.text);
        } else {
            if (!op.op.bare)
                throw ParseError(
                    'Operator without operands',
                    op.start, op.text);
        }
    }
    op.ctype = 'infix';
    op.oper = op.op.sym;
    op.args = [lhs, rhs];
    seq.splice(seq.length - 3, 3, op);
}

// Recursively called for nested brackets. closing is the text of the
// expected closing bracket, which will be treated as closing even if
// it also is an opening bracket, e.g. in the case of |…|.
function parseRec(tokens, closing) {
    // Seq is an alternating list of expressions (even indices) and
    // incomplete operators (odd indices). The order of operator
    // precedences is by increasing value, since if the precedence
    // value were to decrease, previous operators can be applied.
    // In the case of right-associative operators, multiple operators
    // in the sequence can have equal precedence.
    var seq = [];
    var tok; // last token to be processed
    parseLoop: while (true) {
        tok = tokens.next();
        switch (tok.toktype) {
            case 'OP':
                var op = operators[tok.text];
                tok.op = op;
                tok.precedence = op.precedence;
                if (!(seq.length & 1)) seq.push(null);
                while (seq.length >= 3 &&
                    seq[seq.length - 2].precedence <= tok.precedence)
                    applyOperator(seq);
                if (op.rassoc)
                    tok.precedence++;
                seq.push(tok);
                break;
            case 'ID':
                tok.ctype = 'variable';
                tok.name = tok.text;
                if (seq.length & 1)
                    throw ParseError('Missing operator', tok.start, tok.text);
                seq.push(tok);
                break;
            case 'NUM':
                tok.ctype = 'number';
                tok.value = {
                    real: +tok.text,
                    imag: 0
                };
                if (seq.length & 1)
                    throw ParseError('Missing operator', tok.start, tok.text);
                seq.push(tok);
                break;
            case 'STR':
                tok.ctype = 'string';
                tok.value = tok.raw.substring(1, tok.raw.length - 1);
                if (seq.length & 1)
                    throw ParseError('Missing operator', tok.start, tok.text);
                seq.push(tok);
                break;
            case 'BRA':
                var bra = brackets.indexOf(tok.text);
                if (tok.text === closing || bra & 1)
                    break parseLoop;
                var closer = brackets.charAt(bra + 1);
                var sub = parseRec(tokens, closer);
                var ctok = sub.closedBy;
                if (ctok.text !== closer)
                    throw ParseError(
                        'Opening ' + tok.text +
                        ' at ' + tok.start.row + ':' + tok.start.col +
                        ' closed by ' + (ctok.text || 'EOF') +
                        ' at ' + ctok.start.row + ':' + ctok.start.col);
                var pair = tok.text + ctok.text;
                var lst = [];
                var expr = sub.expr;
                if (expr) {
                    while (expr && expr.ctype === 'infix' && expr.oper === ',') {
                        lst.push(expr.args[0]);
                        expr = expr.args[1];
                    }
                    lst.push(expr);
                }
                if (!(seq.length & 1)) { // value position
                    if (pair === '||') {
                        if (lst.length === 1) {
                            seq.push({
                                ctype: 'function',
                                oper: 'abs_infix',
                                args: lst,
                                modifs: {},
                            });
                        } else if (lst.length === 2) {
                            seq.push({
                                ctype: 'function',
                                oper: 'dist_infix',
                                args: lst,
                                modifs: {},
                            });
                        } else {
                            throw ParseError(
                                "Don't support |…| with " + lst.length +
                                ' arguments', tok.start);
                        }
                    } else if (pair !== '[]' && lst.length === 1) {
                        seq.push({
                            ctype: 'paren',
                            args: lst,
                        });
                    } else if (pair !== '{}') {
                        if (lst.length === 0)
                            seq.push({
                                ctype: 'list',
                                value: [],
                            });
                        else
                            seq.push({
                                ctype: 'function',
                                oper: 'genList',
                                args: lst,
                                modifs: {},
                            });
                    } else {
                        throw ParseError('{…} only takes one argument', tok.start);
                    }
                } else { // operator position, so it's a function call
                    var fname = seq[seq.length - 1];
                    if (fname.ctype !== 'variable')
                        throw ParseError(
                            'Function name must be an identifier',
                            fname.start);
                    fname.ctype = 'function';
                    var args = fname.args = [];
                    var modifs = fname.modifs = {};
                    for (var i = 0; i < lst.length; ++i) {
                        var elt = lst[i];
                        if (elt && elt.ctype === 'infix' && elt.oper === '->') {
                            var id = elt.args[0];
                            if (id.ctype !== 'variable')
                                throw ParseError(
                                    'Modifier name must be an identifier',
                                    elt.start);
                            modifs[id.name] = elt.args[1];
                        } else {
                            args.push(elt);
                        }
                    }
                    fname.oper = fname.name + '$' + fname.args.length;
                }
                break;
            case 'EOF':
                break parseLoop;
        }
    }
    if (!(seq.length & 1)) seq.push(null);
    while (seq.length >= 3)
        applyOperator(seq);
    return {
        expr: seq[0],
        closedBy: tok
    };
}

var cvoid = {
    ctype: 'void'
};

function postprocess(expr) {
    if (expr === null)
        return cvoid;
    if (expr) {
        // parent-first postprocessing
        if (expr.ctype === 'infix') {
            if (expr.oper === ':=') {
                var fun = expr.args[0];
                if (fun.ctype === 'function') {
                    fun.args.forEach(function(arg) {
                        if (arg === null || arg.ctype !== 'variable')
                            throw ParseError(
                                'Function argument must be an identifier',
                                arg.start || expr.start);
                    });
                } else if (fun.ctype !== 'variable') {
                    throw ParseError(
                        expr.oper + ' can only be used to define ' +
                        'functions or variables',
                        expr.start);
                }
            }
        }

        if (expr.args)
            expr.args = expr.args.map(postprocess);
        if (expr.modifs)
            for (var key in expr.modifs)
                expr.modifs[key] = postprocess(expr.modifs[key]);

        // parent-last postprocessing
        if (expr.ctype === 'paren') {
            return expr.args[0];
        } else if (expr.ctype === 'infix') {
            if (expr.oper === '.') {
                if (!(expr.args[1] && expr.args[1].ctype === 'variable'))
                    throw ParseError(
                        'Field name must be identifier', expr.start, expr.text);
                expr.ctype = 'field';
                expr.obj = expr.args[0];
                expr.key = expr.args[1].name;
            }
            if (typeof infixmap !== 'undefined')
                expr.impl = infixmap[expr.oper];
        } else if (expr.ctype === 'variable') {
            if (typeof namespace !== 'undefined') {
                if (namespace.isVariable(expr.name)) {
                    return namespace.vars[expr.name];
                } else {
                    return namespace.create(expr.name);
                }
            }
        } else if (expr.ctype === 'function') {
            if (typeof usedFunctions !== 'undefined')
                usedFunctions[expr.oper] = true;
        }
    }
    if (expr && typeof expr === 'object') {
        delete expr.start;
        delete expr.end;
        delete expr.toktype;
        delete expr.op;
        delete expr.raw;
        delete expr.text;
    }
    return expr;
}

function parse(code) {
    try {
        var res = parseRec(new Tokenizer(code));
        if (res.closedBy.toktype !== 'EOF')
            throw ParseError(
                'Closing bracket never opened.',
                res.closedBy.start,
                res.closedBy.text
            );
        return postprocess(res.expr);
    } catch (err) {
        err.ctype = 'error';
        return err;
    }
}

function analyse(code) {
    return parse(code);
}

if (typeof process !== "undefined" &&
    typeof module !== "undefined" &&
    typeof module.exports !== "undefined" &&
    typeof window === "undefined")
    module.exports = parse;
